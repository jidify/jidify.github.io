---
layout: post
title: "docker"
description: ""
category: 
tags: [docker]
---
{% include JB/setup %}

##Installation
Sur mac, il faut un VM pour avoir un linux, donc j’installe **virtualBox** :
   
    brew cask install virtualbox

Ensuite, pour creer et communiquer facilement (ligne de commande) avec la VMs qui exécutera mes containeur *docker*, j’installe **boot2docker** 
  
    brew install boot2docker
    
puis, je créer ma VM 

    boot2docker init
    
et je declare les variables d’environements qui vont bien :

    $ eval "$(boot2docker shellinit)"

>ma VM se trouve sous : `<HOME>/VirtualBox VMs/boot2docker-vm`.  
Elle contient notament toutes les images *docker*, donc ‘gaffe!!
{: .information}

>`boot2docker ip`: affiche l’IP de la VM
>{: .information}

*Voir l’[installation pour Mac](https://docs.docker.com/installation/mac/) sur le site docker.*


##Eléments principaux de docker
    
###Images Docker 
 
Une image docker est un ensemble de fichiers.  
Il existe des images de bases (busybox, ubuntu, debian, ...) sur lesquelles nous pouvons construire nos propres images. 
Les images sont construites en couches.  
Chaque couche ammenant une modification (*diff*) à la précédente couche.  
![image layers](/assets/images/docker/docker_image_layers.png){:height="300px" width="300px"} 
  
L’historique d’une image montre **les étapes** succesives de construction d’une image. 

Les images appartiennent à un __namespace__.  
Il y a __3__ namespaces :

- __Root__ : pour les images __officielles__ (publiées par *Docker-Inc*). Elles servent d’image de base pour nos propres images.  
Elles sont disponibles dans sur *Docker Hub*.  

>`ubuntu` (par exemple)

    
- __User__: Ces images sont disponibles sur *Docker Hub*.  
Par exemple l’image:

>`jdantan/java-8`  
<br>
correspond à l’image `java-8` de l’utilisateur `jdantan`
.

- __Self-hosted__ : Ces images __ne sont pas hébergées__ sur *Docker Hub*. Elles sont hébergées soit en local, soit sur un dépot autre que *Docker Hub* et peuvent être __publiques ou privées__.  
L’image : 

>`localhost:5000/my-private-image`  
<br>
est hébergée sur `localhost` et accessible via le port `5000`.  
Son nom étant `my-private-image`


####Quelques commandes

`docker images` :  affiche les images présentes sur ma machine.
    
`docker pull <image-name>` : charge une image depuis un dépot.

####Tags

Les images peuvent (devraient toujours) avoir des __tags associés__. Ils permettent généralement de préciser une version :

    ubuntu:12.04.5
    ubuntu:14.04.2
    ubuntu:latest
    ....
    
sont des exemples de *version* différente de l’image *ubuntu*.

###Conteneur

Les images docker contiennent __*les informations décrivant un container*__. Ce sont des templates.  
Les __conteneurs sont des processus__ basés sur des images, ou si on peut dire, un conteneur « *contient* » des processus s’éxécutant « *sur* » une image.  
Les conteneurs n’ont d’existances qu’au *runtime* (et sont dans des états tels que : *en cours d’exécution*, *stoppés*, ...). 

Les conteneurs sont démarrer avec la commande `docker run ...` (voir  [ici](#demarrer-un-conteneur-docker)).
 
 
###Dockerfiles

les dockerfiles contiennent le serie de commandes ayant été utilisées pour construire une image docker.

### Docker engine
le *Docker engine* est le composant de ocker gérant les conteneur (au runtime ?) sur notre machine.

###Docker Hub 
*Docker Hub* est un site internet servant de dépot publique pour de nombreuses images docker. 
 
>aprés la 1ere connexion réussie (`docker login`), le fichier de configuration `~/.dockercfg` est créer dans le repertoire *Home*.  
>Ce fichier contient les __informations d’authentification__ du compte utilisateur sur dockerhub (par exemple *https://hub.docker.com/u/jdantan/* en ce qui me concerne), et doit être protégé.
{: .information}

##Demarrer un conteneur docker

###Syntaxe

    docker run [options] image [command][arg ...]
    
exemples:

    docker run busybox echo "hello world"

Démarre un conteneur avec l’image *busybox* et execute « *sur* »  cette image le processus `echo`.

###Options

	docker run -help
	     ou
	docker run -h
	
permet d’afficher la liste des options disponibles.

`-p`: mapping d’un port du conteneur sur la machine hôte.

`-d`: exécute le conteneur en arrière-plan.

>il est possible de voir les process docker en effectuant un :  
- `docker ps` : affiche les process en cours d’exécution.  
- `docker ps -a` : affiche les process terminés et en cours d’exécution.
{: .information}  

`--name=" ..."`: assigne le nom (entre guillemets) au conteneur qu’on démarre. 


###Commandes

- `docker start [ID / Name]`: Démarre un conteneur existant et arreté L’ID/Name est nécessaire si le serveur s’exécutait en arrière-plan.     
    
- `docker stop [ID / Name]` : arrete un conteneur $running*.  
L’ID/Name est nécessaire si le serveur s’exécutait en arrière-plan.

- `docker rm [-f] [ID / Name]` : détruit/supprime un conteneur.  
L’ID/Name est nécessaire si le serveur s’exécutait en arrière-plan. `-f`  est nécessaire si le serveur est démarré.

- `docker log [name]`: affiche les logs du conteneur *name* lancer en mode détaché.

- `docker diff [name]`: affiche les modification effectuées sur le conteneur *name* depuis son lancement.

- `docker cp`: copie des fichier du conteneur vers la machine hôte.

- `docker inspect`: affiche des (tonnes) d’informations à propos d’un conteneur.

- `docker command $(docker command)`: chainage de commandes
	
	
##Construire ses images Docker

###Dockerfile & « docker build »

- un *Dockerfile* contient la définition d’une image.  
Il s’agit d’une serie d’intructions indiquant à *Docker* comment construire l’image.

- la commande `docker build` construit une image à partir d’un *Dockerfile*.

###Syntaxe Dockerfile

    # This is a comment
    FROM ubuntu:14.04
    MAINTAINER Jane miceli <jane@janemiceli.com>
    RUN apt-get update
    RUN apt-get install -y nginx
    RUN echo 'Hi, I am in your container ' \ 
        > /usr/share/nginx/html/index.html
    CMD ["nginx","-g","daemon off;"]

    EXPOSE 80

- `FROM` : image de dépard de notre image. Doit être la __première instruction__. L’instruction `FROM` marque le début d’une nouvelle image.
- `MAINTAINER` : qui à créé/s’occupe de cette image (optionnel - mais fortement recommandé).
- `RUN` : chaque *RUN* exécute une commande nécessaire à la création de notre image et enregistre les changement (équivalent d’un *commit* Git). *RUN* sert à installer des packages, libraries, différents fichiers, ... mais __ne lance pas de proccessus__. 
- `CMD` : commande exécutée par défaut lors du lancement d’un conteneur. __1 seule instance__ par *Dockerfile*.
- `EXPOSE` : liste des ports __public__ à ouvrir au lancement du conteneur.  
Un port *public* est accessible à __l’intérieur et à l’extérieur__ du conteneur alors qu’un port __privé__ n’est __accessible qu’à l’intérieur__ du conteneur.  
`docker run -P ...` ouvre aussi un port, même si le port n’est pas *exposé* dans le *Dockerfile*.

#### Autres instructions utiles

- `ADD` : permet d’ajouter des fichiers/répertoires de la machine hote dans l’image.  

`ADD /src/webapp /opt/webapp` :  
ajoute le contenu de  `/src/webapp` dans le répertoire `/opt/webapp` de l’image.

L’instruction *ADD* peut aussi ajouter des fichiers distants :

 `ADD http://www.example.com/webapp /opt/`
 

###Construire l’image

`docker build -t web .`
    
- le « t » tag l’image construite.
- le « . » définit l’endroit où se trouve le *Dockerfile* (ici le repertoire courant).  

ou:

    docker build -t web https://github.com/docker-training/staticweb.git
    
 - si le *Dockerfile* est sur Github par exemple.

 >L’image construite se trouve alors dans __notre repository local__.
 {: .information}
 
 #### Version
 
 Il est possible d’ajouter un numéro de version lors de la construction d’une image : 
    
    `docker build -t web:0.3.2 .`
